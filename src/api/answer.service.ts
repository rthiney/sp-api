/**
 * surgipal_dev
 * API
 *
 * OpenAPI spec version: 1.5
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Inject, Injectable, Optional } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { Configuration } from '../configuration';
import { CustomHttpUrlEncodingCodec } from '../encoder';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { Item3 } from '../model/item3';
import { Item4 } from '../model/item4';
import { Item5 } from '../model/item5';
import '../rxjs-operators';
import { BASE_PATH } from '../variables';

@Injectable()
export class AnswerService {
  protected basePath = 'http://surgipal.com/api/apistage.php';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();

  constructor(
    protected httpClient: HttpClient,
    @Optional()
    @Inject(BASE_PATH)
    basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
      this.basePath = basePath || configuration.basePath || this.basePath;
    }
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

  /**
   * List
   *
   * @param exclude One or more related entities (comma separated).
   * @param include One or more related entities (comma separated).
   * @param order Column you want to sort on and the sort direction (comma separated). Example: id,desc
   * @param page Page number and page size (comma separated). NB: You cannot use \&quot;page\&quot; without \&quot;order\&quot;! Example: 1,10
   * @param transform Transform the records to object format. NB: This can also be done client-side in JavaScript!
   * @param columns The table columns you want to retrieve (comma separated). Example: posts.*,categories.name
   * @param filter[] Filters to be applied. Each filter consists of a column, an operator and a value (comma separated). Example: id,eq,1
   * @param satisfy Should all filters match (default)? Or any?
   */
  public answerGet(
    exclude?: string,
    include?: string,
    order?: string,
    page?: string,
    transform?: boolean,
    columns?: string,
    filter?: string[],
    satisfy?: string
  ): Observable<InlineResponse2001[]> {
    let queryParameters = new HttpParams({
      encoder: new CustomHttpUrlEncodingCodec()
    });
    if (exclude !== undefined) {
      queryParameters = queryParameters.set('exclude', exclude as any);
    }
    if (include !== undefined) {
      queryParameters = queryParameters.set('include', include as any);
    }
    if (order !== undefined) {
      queryParameters = queryParameters.set('order', order as any);
    }
    if (page !== undefined) {
      queryParameters = queryParameters.set('page', page as any);
    }
    if (transform !== undefined) {
      queryParameters = queryParameters.set('transform', transform as any);
    }
    if (columns !== undefined) {
      queryParameters = queryParameters.set('columns', columns as any);
    }
    if (filter) {
      filter.forEach(element => {
        queryParameters = queryParameters.append('filter[]', element as any);
      });
    }
    if (satisfy !== undefined) {
      queryParameters = queryParameters.set('satisfy', satisfy as any);
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(
      httpHeaderAccepts
    );
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];

    return this.httpClient.get<any>(`${this.basePath}/answer`, {
      params: queryParameters,
      headers,
      withCredentials: this.configuration.withCredentials
    });
  }

  /**
   * Delete
   *
   * @param id Identifier for item.
   */
  public answerIdDelete(id: string): Observable<number> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling answerIdDelete.'
      );
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(
      httpHeaderAccepts
    );
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];

    return this.httpClient.delete<any>(
      `${this.basePath}/answer/${encodeURIComponent(String(id))}`,
      {
        headers,
        withCredentials: this.configuration.withCredentials
      }
    );
  }

  /**
   * Read
   *
   * @param id Identifier for item.
   */
  public answerIdGet(id: string): Observable<InlineResponse2001> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling answerIdGet.'
      );
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(
      httpHeaderAccepts
    );
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];

    return this.httpClient.get<any>(
      `${this.basePath}/answer/${encodeURIComponent(String(id))}`,
      {
        headers,
        withCredentials: this.configuration.withCredentials
      }
    );
  }

  /**
   * Increment
   *
   * @param id Identifier for item.
   * @param item Properties of item to update.
   */
  public answerIdPatch(id: string, item: Item5): Observable<number> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling answerIdPatch.'
      );
    }
    if (item === null || item === undefined) {
      throw new Error(
        'Required parameter item was null or undefined when calling answerIdPatch.'
      );
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(
      httpHeaderAccepts
    );
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string = this.configuration.selectHeaderContentType(
      consumes
    );
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.patch<any>(
      `${this.basePath}/answer/${encodeURIComponent(String(id))}`,
      item,
      {
        headers,
        withCredentials: this.configuration.withCredentials
      }
    );
  }

  /**
   * Update
   *
   * @param id Identifier for item.
   * @param item Properties of item to update.
   */
  public answerIdPut(id: string, item: Item4): Observable<number> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling answerIdPut.'
      );
    }
    if (item === null || item === undefined) {
      throw new Error(
        'Required parameter item was null or undefined when calling answerIdPut.'
      );
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(
      httpHeaderAccepts
    );
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string = this.configuration.selectHeaderContentType(
      consumes
    );
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.put<any>(
      `${this.basePath}/answer/${encodeURIComponent(String(id))}`,
      item,
      {
        headers,
        withCredentials: this.configuration.withCredentials
      }
    );
  }

  /**
   * Create
   *
   * @param item Item to create.
   */
  public answerPost(item: Item3): Observable<number> {
    if (item === null || item === undefined) {
      throw new Error(
        'Required parameter item was null or undefined when calling answerPost.'
      );
    }

    let headers = this.defaultHeaders;

    // to determine the Accept header
    const httpHeaderAccepts: string[] = ['application/json'];
    const httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(
      httpHeaderAccepts
    );
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected);
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string = this.configuration.selectHeaderContentType(
      consumes
    );
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected);
    }

    return this.httpClient.post<any>(`${this.basePath}/answer`, item, {
      headers,
      withCredentials: this.configuration.withCredentials
    });
  }
}
